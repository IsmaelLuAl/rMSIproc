# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

AlignSpectrumToReference <- function(ref, x, bilinear = FALSE, lagRefLow = 0.1, lagRefMid = 0.5, lagRefHigh = 0.9, iterations = 1L, lagLimitppm = 200, fftOverSampling = 2L) {
    .Call('rMSIproc_AlignSpectrumToReference', PACKAGE = 'rMSIproc', ref, x, bilinear, lagRefLow, lagRefMid, lagRefHigh, iterations, lagLimitppm, fftOverSampling)
}

FullImageAlign <- function(fileNames, refSpectrum, numRows, dataType, numOfThreads, AlignmentBilinear = FALSE, AlignmentIterations = 3L, AlignmentMaxShiftPpm = 200L, RefLow = 0.0, RefMid = 0.5, RefHigh = 1.0, OverSampling = 2L) {
    .Call('rMSIproc_FullImageAlign', PACKAGE = 'rMSIproc', fileNames, refSpectrum, numRows, dataType, numOfThreads, AlignmentBilinear, AlignmentIterations, AlignmentMaxShiftPpm, RefLow, RefMid, RefHigh, OverSampling)
}

FullImagePeakPicking <- function(fileNames, mass, numRows, dataType, numOfThreads, SNR = 5, WinSize = 10L, InterpolationUpSampling = 10L, doBinning = TRUE, binningTolerance = 0.05, binningFilter = 0.9) {
    .Call('rMSIproc_FullImagePeakPicking', PACKAGE = 'rMSIproc', fileNames, mass, numRows, dataType, numOfThreads, SNR, WinSize, InterpolationUpSampling, doBinning, binningTolerance, binningFilter)
}

MergePeakMatricesC <- function(PeakMatrices, binningTolerance = 0.05, binningFilter = 0.01) {
    .Call('rMSIproc_MergePeakMatricesC', PACKAGE = 'rMSIproc', PeakMatrices, binningTolerance, binningFilter)
}

ReplacePeakMatrixZeros <- function(PeakMatrix, fileNames, mass, numRows, dataType, numOfThreads, WinSize = 10L, InterpolationUpSampling = 10L) {
    .Call('rMSIproc_ReplacePeakMatrixZeros', PACKAGE = 'rMSIproc', PeakMatrix, fileNames, mass, numRows, dataType, numOfThreads, WinSize, InterpolationUpSampling)
}

FullImageSmoothing <- function(fileNames, massChannels, numRows, dataType, numOfThreads, SmoothingKernelSize = 5L) {
    invisible(.Call('rMSIproc_FullImageSmoothing', PACKAGE = 'rMSIproc', fileNames, massChannels, numRows, dataType, numOfThreads, SmoothingKernelSize))
}

#' NoiseEstimationFFTCosWin.
#' 
#' Estimate the noise of a spectrum using a FFT filter and a cosinus window in frequency domain.
#' 
#' @param x an Rcpp::NumericVector containing the spectrum intensities.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return an Rcpp::NumericVector containing the estimated noise.
NoiseEstimationFFTCosWin <- function(x, filWinSize = 40L) {
    .Call('rMSIproc_NoiseEstimationFFTCosWin', PACKAGE = 'rMSIproc', x, filWinSize)
}

#' NoiseEstimationFFTExpWin.
#' 
#' Estimate the noise of a spectrum using a FFT filter and a decay exponential window in frequency domain.
#' 
#' @param x an Rcpp::NumericVector containing the spectrum intensities.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return an Rcpp::NumericVector containing the estimated noise.
NoiseEstimationFFTExpWin <- function(x, filWinSize = 40L) {
    .Call('rMSIproc_NoiseEstimationFFTExpWin', PACKAGE = 'rMSIproc', x, filWinSize)
}

#' NoiseEstimationFFTCosWinMat.
#' 
#' Estimate the noise of some spectra using a FFT filter and a cosinus window in frequency domain.
#' 
#' @param x an Rcpp::NumericMatrix containing the spectra intensities. Each spectrum in a row.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return an Rcpp::NumericMatrix containing the estimated noise in a matrix where each spectrum is a row.
NoiseEstimationFFTCosWinMat <- function(x, filWinSize = 40L) {
    .Call('rMSIproc_NoiseEstimationFFTCosWinMat', PACKAGE = 'rMSIproc', x, filWinSize)
}

#' NoiseEstimationFFTExpWinMat.
#' 
#' Estimate the noise of some spectra using a FFT filter and a decay exponential window in frequency domain.
#' 
#' @param x an Rcpp::NumericMatrix containing the spectra intensities. Each spectrum in a row.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return a
NoiseEstimationFFTExpWinMat <- function(x, filWinSize = 40L) {
    .Call('rMSIproc_NoiseEstimationFFTExpWinMat', PACKAGE = 'rMSIproc', x, filWinSize)
}

#'LoadPeakMatrix.
#'
#'Loads a binned peaks matrix from HDD.
#'
#'@param path full path to directory from where data must be loaded.
#'@return  an R List containing intensity, SNR and area matrices, mass axis vector and if available the normalizations data.frame.
#'
LoadPeakMatrixC <- function(path) {
    .Call('rMSIproc_LoadPeakMatrixC', PACKAGE = 'rMSIproc', path)
}

#'StorePeakMatrix.
#'
#'Stores a binned peaks matrix to HDD.
#'
#'@param path full path to directory where data must be stored.
#'@param mat an R List containing intensity, SNR and area matrices the mass axis vector and an R data.frame containing a normalization on each column.
#'
StorePeakMatrixC <- function(path, mat) {
    invisible(.Call('rMSIproc_StorePeakMatrixC', PACKAGE = 'rMSIproc', path, mat))
}

#' DetectPeaks_C.
#' 
#' Detect peaks from a Rcpp::NumericVector object and returns data in a R matrix.
#' This method is only exported to be use by R function DetectPeaks which is an actual R function.
#' The returned peak positions follows C indexing style, this is starts with zero.
#' 
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param intensity a NumericVector where peaks must be detected.
#' @param SNR Only peaks with an equal or higher SNR are retained.
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' 
#' @return a NumerixMatrix of 4 rows corresponding to: mass, intensity of the peak,SNR and area.
#' 
DetectPeaks_C <- function(mass, intensity, SNR = 5, WinSize = 20L, UpSampling = 10L) {
    .Call('rMSIproc_DetectPeaks_C', PACKAGE = 'rMSIproc', mass, intensity, SNR, WinSize, UpSampling)
}

#' TestPeakInterpolation_C.
#' 
#' 
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param intensity a NumericVector where peaks must be detected.
#' @param peakIndex the location of the peak to interpolate in the spectrum.  
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' @param useHanning if hanning windowing must be used befor interpolation.
#' @param Iterations number of iterations to perform. This is just for testing interpolation efficiency
#' 
#' @return a NumerixVector with the FFT interpolated peak shape.
#' 
TestPeakInterpolation_C <- function(mass, intensity, peakIndex, WinSize = 20L, UpSampling = 10L, useHanning = FALSE, Iterations = 1L) {
    .Call('rMSIproc_TestPeakInterpolation_C', PACKAGE = 'rMSIproc', mass, intensity, peakIndex, WinSize, UpSampling, useHanning, Iterations)
}

#' TestHanningWindow.
#' 
#' Method to test the implementation of Hanning window in R session.
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' 
#' @return a NumericVector containing the Hanning Window.
#' 
TestHanningWindow <- function(mass, WinSize = 20L, UpSampling = 10L) {
    .Call('rMSIproc_TestHanningWindow', PACKAGE = 'rMSIproc', mass, WinSize, UpSampling)
}

#' TestAreaWindow.
#' 
#' Method to test the implementation of Area window in R session.
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' 
#' @return a NumericVector containing the Area Window.
#' 
TestAreaWindow <- function(mass, WinSize = 20L, UpSampling = 10L) {
    .Call('rMSIproc_TestAreaWindow', PACKAGE = 'rMSIproc', mass, WinSize, UpSampling)
}

PrintrMSIObjectInfo <- function(fileNames, massChannels, numRows, dataType) {
    invisible(.Call('rMSIproc_PrintrMSIObjectInfo', PACKAGE = 'rMSIproc', fileNames, massChannels, numRows, dataType))
}

LoadrMSIDataCube <- function(fileNames, massChannels, numRows, dataType, cubeSel) {
    .Call('rMSIproc_LoadrMSIDataCube', PACKAGE = 'rMSIproc', fileNames, massChannels, numRows, dataType, cubeSel)
}

#' Smoothing_SavitzkyGolay.
#' 
#' Computes the Savitzky-Golay smoothing of a vector x using a filter size of sgSize.
#' @param x the data vector to smooth.
#' @param sgSize valid values are: 5, 7, 9, 11, 13, 15.
#' @return the smoothed data vector.
Smoothing_SavitzkyGolay <- function(x, sgSize = 5L) {
    .Call('rMSIproc_Smoothing_SavitzkyGolay', PACKAGE = 'rMSIproc', x, sgSize)
}

